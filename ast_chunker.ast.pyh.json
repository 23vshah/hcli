{
  "phy_chunks": {
    "main": {
      "id": "main",
      "type": "module",
      "children": [
        {
          "id": "imports",
          "type": "imports",
          "description": "import standard libraries: ast, json, typing components (Dict, List, Any, Optional, Tuple), and datetime",
          "line_range": [
            1,
            4
          ]
        },
        {
          "id": "class_CodeChunker",
          "type": "class_definition",
          "signature": "class CodeChunker",
          "children": [
            {
              "id": "CodeChunker___init__",
              "type": "method_definition",
              "signature": "method __init__(takes self)",
              "description": "initialize instance variables: chunks dictionary, chunk counters for different node types, source lines list, and mapping dictionaries for nodes to chunk IDs",
              "line_range": [
                8,
                18
              ]
            },
            {
              "id": "CodeChunker_chunk_file",
              "type": "method_definition",
              "signature": "method chunk_file(takes self and file_path)",
              "children": [
                {
                  "id": "file_reading",
                  "type": "with_statement",
                  "description": "read source code from file and split into lines",
                  "line_range": [
                    22,
                    25
                  ]
                },
                {
                  "id": "ast_parsing",
                  "type": "try_statement",
                  "description": "parse source code into AST tree with error handling",
                  "line_range": [
                    27,
                    30
                  ]
                },
                {
                  "id": "two_pass_processing",
                  "type": "sequential_calls",
                  "description": "first pass creates chunk IDs and structure, second pass populates content, then return output structure",
                  "line_range": [
                    33,
                    38
                  ]
                }
              ]
            },
            {
              "id": "CodeChunker__first_pass_create_ids",
              "type": "method_definition",
              "signature": "method _first_pass_create_ids(takes self and tree)",
              "children": [
                {
                  "id": "main_chunk_init",
                  "type": "assignment",
                  "description": "create main module chunk with basic structure",
                  "line_range": [
                    44,
                    51
                  ]
                },
                {
                  "id": "recursive_id_creation",
                  "type": "method_call",
                  "description": "recursively create IDs for all nodes in the tree body",
                  "line_range": [
                    54,
                    54
                  ]
                }
              ]
            },
            {
              "id": "CodeChunker__create_ids_recursive",
              "type": "method_definition",
              "signature": "method _create_ids_recursive(takes self, nodes, and parent_scope)",
              "children": [
                {
                  "id": "node_processing_loop",
                  "type": "for_loop",
                  "description": "iterate through each node and create appropriate chunks based on node type: classes with methods, functions, if/elif/else blocks, for/while loops, try blocks, and with statements, handling nested structures recursively",
                  "line_range": [
                    59,
                    261
                  ]
                }
              ]
            },
            {
              "id": "CodeChunker__second_pass_populate_content",
              "type": "method_definition",
              "signature": "method _second_pass_populate_content(takes self and tree)",
              "children": [
                {
                  "id": "main_blocks_population",
                  "type": "for_loop",
                  "description": "populate main module's code blocks with either chunk references for complex nodes or direct code content for simple statements",
                  "line_range": [
                    267,
                    284
                  ]
                },
                {
                  "id": "chunk_content_population",
                  "type": "for_loop",
                  "description": "populate content for all non-main chunks by finding their corresponding AST nodes and processing them",
                  "line_range": [
                    287,
                    294
                  ]
                }
              ]
            },
            {
              "id": "CodeChunker__find_node_by_chunk_id",
              "type": "method_definition",
              "signature": "method _find_node_by_chunk_id(takes self, tree, and chunk_id)",
              "description": "find AST node corresponding to a chunk ID by searching through node mapping dictionaries, with special handling for else statements",
              "line_range": [
                296,
                313
              ]
            },
            {
              "id": "CodeChunker__populate_chunk_content",
              "type": "method_definition",
              "signature": "method _populate_chunk_content(takes self, node, and chunk_id)",
              "children": [
                {
                  "id": "else_statements_handling",
                  "type": "if_statement",
                  "description": "special handling for else statement chunks by processing their statement lists",
                  "line_range": [
                    320,
                    337
                  ]
                },
                {
                  "id": "node_type_processing",
                  "type": "if_else_block",
                  "description": "process different node types: classes (with member references), functions/methods (delegated to separate handler), if-else blocks (with container and individual chunk handling), for loops (with header and body processing), and while loops",
                  "line_range": [
                    339,
                    442
                  ]
                }
              ]
            },
            {
              "id": "CodeChunker__populate_function_content",
              "type": "method_definition",
              "signature": "method _populate_function_content(takes self, node, and chunk_id)",
              "children": [
                {
                  "id": "function_signature_creation",
                  "type": "assignment",
                  "description": "create function signature with name, arguments, and return type annotation",
                  "line_range": [
                    455,
                    460
                  ]
                },
                {
                  "id": "function_body_processing",
                  "type": "for_loop",
                  "description": "process function body statements, creating chunk references for complex statements or direct code blocks for simple ones",
                  "line_range": [
                    463,
                    478
                  ]
                }
              ]
            },
            {
              "id": "utility_methods",
              "type": "method_group",
              "children": [
                {
                  "id": "CodeChunker__get_body_end_line",
                  "type": "method_definition",
                  "signature": "method _get_body_end_line(takes self and body)",
                  "description": "get the last line number of a statement body, returning 0 if empty",
                  "line_range": [
                    480,
                    484
                  ]
                },
                {
                  "id": "CodeChunker__get_source_segment",
                  "type": "method_definition",
                  "signature": "method _get_source_segment(takes self, node, include_body, body_only_if)",
                  "description": "extract source code for AST node with options to include body content, handling indentation normalization and line range calculation",
                  "line_range": [
                    486,
                    519
                  ]
                },
                {
                  "id": "CodeChunker__extract_dependencies",
                  "type": "method_definition",
                  "signature": "method _extract_dependencies(takes self and node)",
                  "description": "extract variable dependencies by walking AST and finding loaded name nodes",
                  "line_range": [
                    521,
                    527
                  ]
                },
                {
                  "id": "CodeChunker__extract_top_level_definitions",
                  "type": "method_definition",
                  "signature": "method _extract_top_level_definitions(takes self and tree)",
                  "description": "extract names of top-level class and function definitions from module body",
                  "line_range": [
                    529,
                    537
                  ]
                },
                {
                  "id": "CodeChunker__get_args_string",
                  "type": "method_definition",
                  "signature": "method _get_args_string(takes self and args)",
                  "description": "convert function argument list to comma-separated string",
                  "line_range": [
                    539,
                    542
                  ]
                },
                {
                  "id": "CodeChunker__get_returns_string",
                  "type": "method_definition",
                  "signature": "method _get_returns_string(takes self and node)",
                  "description": "get return type annotation as string, defaulting to 'None' if no annotation",
                  "line_range": [
                    544,
                    548
                  ]
                }
              ]
            },
            {
              "id": "output_methods",
              "type": "method_group",
              "children": [
                {
                  "id": "CodeChunker__create_error_chunk",
                  "type": "method_definition",
                  "signature": "method _create_error_chunk(takes self, source_code, and error_msg)",
                  "description": "create fallback chunk structure when AST parsing fails, containing entire source as single code block",
                  "line_range": [
                    550,
                    572
                  ]
                },
                {
                  "id": "CodeChunker__create_output_structure",
                  "type": "method_definition",
                  "signature": "method _create_output_structure(takes self and file_path)",
                  "description": "create final output structure with metadata, chunks, relationships, and context map",
                  "line_range": [
                    574,
                    586
                  ]
                },
                {
                  "id": "CodeChunker__build_relationships",
                  "type": "method_definition",
                  "signature": "method _build_relationships(takes self)",
                  "description": "build relationship mappings with execution flow starting from main and empty dependency graph",
                  "line_range": [
                    588,
                    599
                  ]
                },
                {
                  "id": "CodeChunker__build_context_map",
                  "type": "method_definition",
                  "signature": "method _build_context_map(takes self)",
                  "description": "build global context mapping with empty lists for imports, variables, functions, and classes",
                  "line_range": [
                    601,
                    608
                  ]
                }
              ]
            }
          ]
        },
        {
          "id": "function_main",
          "type": "function_definition",
          "signature": "function main()",
          "children": [
            {
              "id": "argument_validation",
              "type": "if_statement",
              "description": "validate command line arguments, exit with usage message if incorrect",
              "line_range": [
                615,
                617
              ]
            },
            {
              "id": "chunking_process",
              "type": "sequential_processing",
              "description": "get file path from arguments, create CodeChunker instance, then process file with try-catch error handling and output results",
              "line_range": [
                619,
                635
              ]
            }
          ]
        },
        {
          "id": "main_guard",
          "type": "if_statement",
          "description": "standard Python main guard to execute main function when script is run directly",
          "line_range": [
            638,
            639
          ]
        }
      ]
    }
  },
  "metadata": {
    "source_py": "ast_chunker.py"
  }
}